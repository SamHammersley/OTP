package com.samhg.authentication.key;

import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import static com.samhg.authentication.key.KeyConstants.*;

/**
 * A wrapper class of {@link SecureRandom} which places restrictions on the number of times
 */
public final class ReseedingSecureRandom {

	/**
	 * A {@link SecureRandom} for PRNG.
	 */
	private final SecureRandom random = getInstance();

	/**
	 * The number of bytes generated by {@link #getNextBytes(int)} before {@link #random} should be reseeded.
	 */
	private final long reseedBytes;

	/**
	 * The amount of time before {@link #random} should be reseeded.
	 */
	private final long reseedInterval;

	/**
	 * The amount of bytes that {@link #random} has generated.
	 */
	private int bytesGenerated;
	
	/**
	 * The time at which {@link #random} was previously updated.
	 */
	private long lastUpdate = System.nanoTime();

	public ReseedingSecureRandom(long reseedBytes, long reseedInterval) {
		this.reseedBytes = reseedBytes;
		this.reseedInterval = reseedInterval;
	}

	public ReseedingSecureRandom() {
		this(DEFAULT_RESEED_BYTES, DEFAULT_RESEED_INTERVAL);
	}
	
	/**
	 * Checks if random requires reseeding. This is the case when there have been either
	 * {@link KeyConstants#DEFAULT_RESEED_BYTES} or {@link KeyConstants#DEFAULT_RESEED_INTERVAL} has
	 * elapsed between calls to the random.
	 *
	 * This method should be called before any use of {@link #random} to assure that
	 * it is re-seeded periodically.
	 */
	private void updateRandom() {
		if (bytesGenerated >= reseedBytes || System.nanoTime() - lastUpdate >= reseedInterval) {
			lastUpdate = System.nanoTime();
			bytesGenerated = 0;
			random.reseed();
		}
	}

	/**
	 * Gets an instance of {@link SecureRandom} using {@link KeyConstants#ALGORITHM} and
	 * {@link KeyConstants#PROVIDER} as the algorithm and provider parameters respectively.
	 *
	 * @return a {@link SecureRandom} instance.
	 */
	private SecureRandom getInstance() {
		try {
			return SecureRandom.getInstance(ALGORITHM, PROVIDER);

		} catch (GeneralSecurityException e) {
			throw new RuntimeException("Failed to get SecureRandom instance.");
		}
	}

	/**
	 * Gets the next bytes from {@link #random} and stores them in an array.
	 * 
	 * @param size the size of the array.
	 * @return an array of random bytes.
	 */
	public byte[] getNextBytes(int size) {
		updateRandom();

		byte[] bytes = new byte[size];
		random.nextBytes(bytes);
		bytesGenerated += size;

		return bytes;
	}
	
	/**
	 * Gets {@link #random} and calls {@link #updateRandom}
	 * 
	 * @return
	 */
	public SecureRandom getSecureRandom() {
		updateRandom();

		return random;
	}
	
}