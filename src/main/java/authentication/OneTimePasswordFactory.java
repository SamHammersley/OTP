package authentication;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import authentication.keys.KeyCache;
import authentication.specifications.OtpGeneratorSpecification;

import com.google.common.base.Strings;
import com.google.common.io.BaseEncoding;

/**
 * Structure for OTP algorithms. Implementations limited to HOTP and TOTP, these
 * two implementations are similar in the way that passwords are calculated.
 * However, TOTP uses the current time stamp whereas HOTP uses a counter.
 * 
 * <p>
 * This class does not take specific parameters to calculate one-time passwords
 * that's down to the implementation to decide.
 * </p>
 *
 * @author Sam
 * @see <a
 *      href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">
 *      Time-based One Time Password algorithm</a>
 * @see <a
 *      href="http://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm">
 *      HMAC-based One Time Password algorithm</a>
 */
public abstract class OneTimePasswordFactory<T extends OtpGeneratorSpecification> {
	
	/**
	 * Contains specific details required for this factory to create valid passwords.
	 */
	protected final T specification;
	
	/**
	 * {@link KeyCache} implementation used to get and store keys.
	 */
	protected final KeyCache repository;

	/**
	 * An instance of secure random used for the secret key generation.
	 */
	private final SecureRandom random;
	
	/**
	 * Constructs a new {@link OneTimePasswordAlgorithm} instance.
	 * The instance of random is instantiated using a fixed number of
	 * operations and time before re-seeding.
	 * 
	 * @param specification containing information about a specific implementation.
	 * @param hashAlgorithm the secure hash algorithm to use for HMAC calculation.
	 * @param repository the repository for storing and retrieval of secret keys at runtime.
	 * @param random An instance of secure random used for the secret key generation.
	 */
	public OneTimePasswordFactory(T specification, KeyCache repository, SecureRandom random) {
		this.specification = specification;
		this.repository = repository;
		this.random = random;
	}
	
	/**
	 * This method defines how the passwords are created and validated.
	 * 
	 * @param encodedKey the secret key encoded using Base32 encoding.
	 * @param password the one-time password, created by google authenticator (or something application).
	 * @return <code>true</code> if the password is valid. 
	 */
	protected abstract boolean validatePassword(String encodedKey, int password);
	
	/**
	 * Validates password for a specific identifier by getting the secret key 
	 * from the repository.
	 * 
	 * @param identifier the identifier that is used to get the secret key.
	 * @param password the password being checked.
	 * @return <code>true</code> if the password is valid.
	 * @throws Exception when either the identifier doesn't exist or there was a problem getting the password from the data source.
	 */
	public boolean validatePasswordForIdentifier(String identifier, int password) throws Exception {
		return validatePassword(repository.get(identifier), password);
	}

	/**
	 * Creates a password using {@link #hashAlgorithm} with the specified key
	 * and message.
	 *
	 * @param secretKey
	 *            a string of randomly generated bytes used in the process of
	 *            calculating a one-time password.
	 * @param message
	 *            the message
	 * @return the (6-digit) one time password.
	 */
	public int createPassword(byte[] secretKey, byte[] message) {
		byte[] hash = createHMACHash(secretKey, message);
		int truncatedHash = truncate(hash);
		return Integer.parseInt(Strings.padStart(Integer.toString(truncatedHash), specification.getPasswordLength(), '0'));
	}
	
	/**
	 * Creates a secret key for the specified identifier.
	 * A random string of 8 bytes is generated by the secure random
	 * and then is encoded with Base32 encoding to produce a 16 byte
	 * string of characters/numbers from the Base32 alphabet, A-Z, 2-7.
	 * 
	 * @param identifier the identifier associated with the secret key.
	 * @return a Base32 encoded string, the secret key.
	 * @throws Exception if there is a problem storing the key.
	 */
	public String createKey(String identifier) throws Exception {
		int keyLength = specification.getKeyLength();
		byte[] key = new byte[keyLength];
		random.nextBytes(key);
		
		String encodedKey = BaseEncoding.base32().encode(key);
		repository.put(identifier, encodedKey);
		
		return encodedKey;
	}

	/**
	 * <p>
	 * Defines an offset as the 4 least significant bits of the last byte in the
	 * hash, this offset is then used to get 4 bytes from the hash, starting at
	 * the offset. We take these 4 bytes and store it in a 32-bit integer.
	 * </p>
	 * 
	 * <p>
	 * To prevent incorrect interpretation of the value, the most significant
	 * bit is truncated. If it was not, the value may be interpreted as a
	 * negative as primitive data types are signed.
	 * </p>
	 * 
	 * @param hash
	 *            the HMAC, data is selected from this array and stored in a 32-bit
	 *            integer.
	 * @return a truncated version of the hash specified.
	 */
	private int truncate(byte[] hash) {
		int offset = hash[hash.length - 1] & 0xF;
		int truncated = 0;
		
		for (int i = offset; i < offset + 4; ++i) {
			truncated <<= 8;
			truncated += (hash[i] & 0xFF);
		}
		truncated &= ~(1 << 31);
		return truncated %= Math.pow(10, specification.getPasswordLength());
	}
	
	/**
	 * Creates a (Hash-based) Message Authentication Code using the specified hash function,
	 * key and message.
	 * 
	 * @param key the key that is combined with the message.
	 * @param message the data that is combined with the key.
	 * 
	 * @return a hash created by hashing the key and message
	 */
	private byte[] createHMACHash(byte[] key, byte[] message) {
		try {
			String algorithm = specification.getAlgorithm().getAlgorithmName();
			
			Mac mac = Mac.getInstance(algorithm);
			mac.init(new SecretKeySpec(key, algorithm));
			return mac.doFinal(message);
		} catch (NoSuchAlgorithmException | InvalidKeyException e) {
			e.printStackTrace();
			return null;
		}
	}

}